"use strict";(self.webpackChunk_zjlab_fe_data_hub_ui=self.webpackChunk_zjlab_fe_data_hub_ui||[]).push([[488],{20488:(r,n,e)=>{e.d(n,{default:()=>l});const l="# File Uploader\r\n\r\n一个支持分片上传、进度追踪的文件上传组件。断点续传 is still in progress\r\n\r\n## 目录\r\n\r\n- [导出清单](#导出清单)\r\n- [代码演示](#代码演示)\r\n- [快速开始](#快速开始)\r\n  - [基础用法](#基础用法)\r\n  - [自定义 UI](#自定义-ui)\r\n- [UploadProvider 详解](#uploadprovider-详解)\r\n  - [它负责什么？](#它负责什么)\r\n  - [放在哪里？](#放在哪里)\r\n  - [配置项](#配置项)\r\n  - [小贴士](#小贴士)\r\n- [FileUploader 组件详解](#fileuploader-组件详解)\r\n  - [Props](#props)\r\n  - [Handlers（上传回调）](#handlers上传回调)\r\n  - [错误处理](#错误处理)\r\n  - [自定义样式](#自定义样式)\r\n  - [使用场景](#使用场景)\r\n- [Hooks 详解](#hooks-详解)\r\n  - [useUpload](#useupload)\r\n  - [useUploadFiles](#useuploadfiles)\r\n  - [useUploadOperations](#useuploadoperations)\r\n  - [useUploadControl](#useuploadcontrol)\r\n  - [useUploadBatch](#useuploadbatch)\r\n  - [如何选择 Hook？](#如何选择-hook)\r\n- [子组件详解](#子组件详解)\r\n  - [UploaderDropZone](#uploaderdropzone)\r\n  - [UploaderFileListLayout](#uploaderfilelistlayout)\r\n  - [UploaderFileItem](#uploaderfileitem)\r\n  - [组合使用完整示例](#组合使用完整示例)\r\n\r\n## 导出清单\r\n\r\n### Provider\r\n\r\n| 导出 | 说明 |\r\n| --- | --- |\r\n| `UploadProvider` | 状态管理 Provider，负责管理上传状态和全局配置。在 App 或页面根部包裹使用。 |\r\n\r\n### 组件\r\n\r\n| 导出 | 说明 |\r\n| --- | --- |\r\n| `FileUploader` | 开箱即用的完整上传器，包含拖拽区和文件列表，文件选择后自动开始上传。 |\r\n| `UploaderDropZone` | 拖拽上传区域，支持点击选择、拖拽文件、文件夹上传。 |\r\n| `UploaderFileListLayout` | 文件列表容器，显示文件数量和空状态。 |\r\n| `UploaderFileItem` | 单个文件项，展示文件名、状态、进度，以及暂停/继续/取消按钮。 |\r\n\r\n### Hooks\r\n\r\n| 导出 | 说明 |\r\n| --- | --- |\r\n| `useUpload` | **主 Hook**，整合了下面所有 Hook 的功能，适合需要完整上传能力的场景。 |\r\n| `useUploadFiles` | 只读文件状态。返回 `files`、`pendingFiles`、`uploadingFiles`、`successFiles`、`failedFiles`、`pausedFiles` 和 `getFileById`。 |\r\n| `useUploadOperations` | 文件队列管理。提供 `addFiles`、`removeFile`、`clearSucceeded`、`clearAll`。 |\r\n| `useUploadControl` | 单文件控制。提供 `start`、`pause`、`resume`、`cancel`。 |\r\n| `useUploadBatch` | 批量操作。提供 `startAll`、`pauseAll`、`resumeAll`、`cancelAll`。 |\r\n\r\n## 代码演示\r\n\r\n<demo src=\"@/components/file-uploader/demo/index.tsx\"></demo>\r\n\r\n## 快速开始\r\n\r\n### 基础用法\r\n\r\n最简单的方式是使用 `FileUploader` 组件，它已经帮你把拖拽区和文件列表都搞定了：\r\n\r\n```tsx\r\nimport { UploadProvider, FileUploader } from '@/components/file-uploader';\r\n\r\nfunction MyPage() {\r\n  const handlers = {\r\n    // 必填：获取上传地址\r\n    onGetUploadUrls: async (fileName, partCount) => {\r\n      const res = await api.getUploadUrls(fileName, partCount);\r\n      return { success: true, uploadInfo: res };\r\n    },\r\n    // 必填：单个分片上传完成\r\n    onPartComplete: async (fileName, uploadId, partNum) => {\r\n      await api.onPartComplete(fileName, uploadId, partNum);\r\n      return { success: true };\r\n    },\r\n    // 必填：整个文件上传完成\r\n    onFileComplete: async (fileName, uploadId) => {\r\n      await api.onFileComplete(fileName, uploadId);\r\n      return { success: true };\r\n    },\r\n  };\r\n\r\n  return (\r\n    <UploadProvider>\r\n      <FileUploader handlers={handlers} />\r\n    </UploadProvider>\r\n  );\r\n}\r\n```\r\n\r\n### 自定义 UI\r\n\r\n如果你想自己控制 UI，可以直接用 Hook：\r\n\r\n```tsx\r\nimport { UploadProvider, useUpload, UploaderDropZone } from '@/components/file-uploader';\r\n\r\nfunction CustomUploader({ datasetId }: { datasetId: string }) {\r\n  const { files, addFiles, start, pause, cancel } = useUpload();\r\n\r\n  const handleDrop = (droppedFiles: File[]) => {\r\n    addFiles(droppedFiles, {\r\n      handlers: {\r\n        onGetUploadUrls: (fileName, partCount) => api.getUploadUrls(datasetId, fileName, partCount),\r\n        onPartComplete: (fileName, uploadId, partNum) => api.onPartComplete(datasetId, uploadId, partNum),\r\n        onFileComplete: (fileName, uploadId) => api.onFileComplete(datasetId, uploadId),\r\n      },\r\n    });\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <UploaderDropZone onDrop={handleDrop} />\r\n      <ul>\r\n        {files.map((file) => (\r\n          <li key={file.id}>\r\n            {file.fileName} - {file.status} ({file.progress}%)\r\n            <button onClick={() => start(file.id)}>开始</button>\r\n            <button onClick={() => pause(file.id)}>暂停</button>\r\n            <button onClick={() => cancel(file.id)}>取消</button>\r\n          </li>\r\n        ))}\r\n      </ul>\r\n    </div>\r\n  );\r\n}\r\n\r\n// 记得在外层包 Provider\r\nfunction App() {\r\n  return (\r\n    <UploadProvider>\r\n      <CustomUploader datasetId=\"123\" />\r\n    </UploadProvider>\r\n  );\r\n}\r\n```\r\n\r\n## UploadProvider 详解\r\n\r\n`UploadProvider` 是整个上传系统的核心，所有上传组件和 Hook 都依赖它。如果你在没有 Provider 的情况下使用 Hook，会直接报错提醒你。\r\n\r\n### 它负责什么？\r\n\r\n- **状态管理**：统一管理所有文件的上传状态（pending、uploading、paused、success、failed 等）\r\n- **上传队列**：内置 QueueManager，自动控制并发上传，不用担心同时传太多文件把带宽打满\r\n- **全局配置**：分片大小、并发数等配置在这里统一设置\r\n\r\n### 放在哪里？\r\n\r\n建议放在 App 根组件或页面根部。同一个 Provider 下的所有上传组件会**共享状态**，这意味着：\r\n\r\n```tsx\r\n// ✅ 推荐：App 级别，整个应用共享上传状态\r\nfunction App() {\r\n  return (\r\n    <UploadProvider>\r\n      <Router>\r\n        <Routes />\r\n      </Router>\r\n    </UploadProvider>\r\n  );\r\n}\r\n\r\n// ✅ 也可以：页面级别，该页面内共享\r\nfunction DatasetPage() {\r\n  return (\r\n    <UploadProvider>\r\n      <DatasetUploader />\r\n      <SomeOtherComponent /> {/* 这里也能通过 useUpload 访问上传状态 */}\r\n    </UploadProvider>\r\n  );\r\n}\r\n\r\n// ⚠️ 注意：多个 Provider 会隔离状态\r\n<UploadProvider>\r\n  <UploaderA /> {/* 这两个上传器的文件列表是分开的 */}\r\n</UploadProvider>\r\n<UploadProvider>\r\n  <UploaderB /> {/* 互不影响 */}\r\n</UploadProvider>\r\n```\r\n\r\n### 配置项\r\n\r\n通过 `config` prop 可以调整全局上传行为：\r\n\r\n```tsx\r\n<UploadProvider\r\n  config={{\r\n    maxChunkSize: 100 * 1024 * 1024,  // 最大分片大小，默认 100MB\r\n    minChunkSize: 5 * 1024 * 1024,    // 最小分片大小，默认 5MB\r\n    concurrentChunks: 2,               // 单文件并发分片数，默认 2\r\n    concurrentFiles: 1,                // 同时上传文件数，默认 1\r\n  }}\r\n>\r\n  <App />\r\n</UploadProvider>\r\n```\r\n\r\n| 配置项 | 类型 | 默认值 | 说明 |\r\n| --- | --- | --- | --- |\r\n| `maxChunkSize` | `number` | `100MB` | 单个分片的最大大小 |\r\n| `minChunkSize` | `number` | `5MB` | 单个分片的最小大小 |\r\n| `concurrentChunks` | `number` | `2` | 每个文件同时上传的分片数 |\r\n| `concurrentFiles` | `number` | `1` | 同时上传的文件数量 |\r\n\r\n### 小贴士\r\n\r\n- 分片大小会根据文件大小自动计算，在 `minChunkSize` 和 `maxChunkSize` 之间动态调整\r\n- `concurrentFiles` 设置为 1 时是串行上传，适合带宽有限或服务端有限制的场景\r\n- 如果需要在不同页面使用完全独立的上传队列，可以用多个 Provider 隔离\r\n- **并发数建议**：由于浏览器对同一域名有并发请求数限制（通常 6 个），建议 `concurrentChunks × concurrentFiles < 5`，给其他请求留点余量\r\n\r\n## FileUploader 组件详解\r\n\r\n`FileUploader` 是开箱即用的完整上传组件，内部集成了拖拽区（`UploaderDropZone`）和文件列表（`UploaderFileListLayout` + `UploaderFileItem`）。选择文件后会自动开始上传，适合大多数场景直接使用。\r\n\r\n### Props\r\n\r\n| 属性 | 类型 | 默认值 | 必填 | 说明 |\r\n| --- | --- | --- | --- | --- |\r\n| `handlers` | `UploadHandlers` | - | ✅ | 上传生命周期回调，详见下方 Handlers 说明 |\r\n| `accept` | `string` | `''` | | 允许的文件类型，如 `\"image/*\"` 或 `\".pdf,.doc\"` |\r\n| `directory` | `boolean` | `false` | | 是否支持文件夹上传 |\r\n| `maxFiles` | `number` | - | | 最大文件数量限制 |\r\n| `maxSize` | `number` | `10GB` | | 单文件大小限制（字节） |\r\n| `dragAreaDescription` | `ReactNode` | `'点击或拖拽上传文件'` | | 拖拽区提示文案 |\r\n| `fileValidation` | `(file: File) => boolean \\| Promise<boolean>` | - | | 自定义文件校验函数，在文件进入上传队列**之前**执行 |\r\n| `onDropZoneError` | `(error: DropZoneError) => void` | - | | 文件进入上传队列**之前**的校验错误回调（如文件过大、数量超限等） |\r\n| `classNames` | `object` | - | | 自定义样式类名 |\r\n\r\n### Handlers（上传回调）\r\n\r\n`handlers` 是上传的核心配置，用于对接你的后端 API。\r\n\r\n#### 必填回调\r\n\r\n| 回调 | 参数 | 返回值 | 说明 |\r\n| --- | --- | --- | --- |\r\n| `onGetUploadUrls` | `(fileName, partCount)` | `Promise<GetUploadUrlsResult>` | 获取分片上传地址 |\r\n| `onPartComplete` | `(fileName, uploadId, partNum)` | `Promise<CallbackResult>` | 单个分片上传完成后通知服务端 |\r\n| `onFileComplete` | `(fileName, uploadId)` | `Promise<CallbackResult>` | 所有分片上传完成后通知服务端（通常触发合并） |\r\n\r\n**返回值类型说明：**\r\n\r\n```ts\r\n// onGetUploadUrls 返回值\r\ntype GetUploadUrlsResult =\r\n  | { success: false; reason?: string }\r\n  | { success: true; uploadInfo: { uploadUrls: UploadUrl[]; uploadId: string } };\r\n\r\n// uploadUrls 数组中每个元素的结构\r\ninterface UploadUrl {\r\n  uploadUrl: string;  // 分片上传地址\r\n  partNum: number;    // 分片序号\r\n}\r\n\r\n// onPartComplete / onFileComplete 返回值\r\ntype CallbackResult =\r\n  | { success: true }\r\n  | { success: false; reason?: string };\r\n```\r\n\r\n**示例：**\r\n\r\n```tsx\r\nconst handlers = {\r\n  onGetUploadUrls: async (fileName, partCount) => {\r\n    const res = await api.getUploadUrls(fileName, partCount);\r\n    // 返回成功\r\n    return { success: true, uploadInfo: { uploadUrls: res.urls, uploadId: res.uploadId } };\r\n    // 或返回失败\r\n    // return { success: false, reason: '获取上传地址失败' };\r\n  },\r\n\r\n  onPartComplete: async (fileName, uploadId, partNum) => {\r\n    await api.onPartComplete(fileName, uploadId, partNum);\r\n    return { success: true };\r\n  },\r\n\r\n  onFileComplete: async (fileName, uploadId) => {\r\n    await api.onFileComplete(fileName, uploadId);\r\n    return { success: true };\r\n  },\r\n};\r\n```\r\n\r\n#### 可选回调\r\n\r\n| 回调 | 参数 | 返回值 | 说明 |\r\n| --- | --- | --- | --- |\r\n| `onBeforeUpload` | `(file: UploadFile)` | `Promise<CallbackResult>` | 上传前校验，返回 `{ success: false }` 可取消上传 |\r\n| `onUploadStart` | `(file: UploadFile)` | `void` | 开始上传时触发（获取到上传地址后） |\r\n| `onProgress` | `(file: UploadFile, progress: number)` | `void` | 进度更新（0-100） |\r\n| `onPause` | `(file: UploadFile)` | `void` | 暂停时触发 |\r\n| `onResume` | `(file: UploadFile)` | `void` | 恢复时触发 |\r\n| `onUploadSuccess` | `(file: UploadFile)` | `void` | 上传成功时触发 |\r\n| `onUploadCancel` | `(fileName, uploadId)` | `Promise<CallbackResult>` | 取消上传，通知服务端清理资源 |\r\n| `onDeleteFile` | `(file: UploadFile)` | `Promise<CallbackResult>` | 从队列中删除文件时触发 |\r\n| `onError` | `(file: UploadFile, error: Error)` | `void` | 上传出错时触发 |\r\n\r\n### 错误处理\r\n\r\n当文件校验失败时（比如文件太大、数量超限），会触发 `onDropZoneError`：\r\n\r\n```tsx\r\n<FileUploader\r\n  handlers={handlers}\r\n  maxSize={100 * 1024 * 1024} // 100MB\r\n  maxFiles={10}\r\n  onDropZoneError={(error) => {\r\n    // error.type: 'FILE_TOO_LARGE' | 'TOO_MANY_FILES' | 'INVALID_TYPE' | 'DROP_FAILED'\r\n    // error.message: 错误描述\r\n    // error.rejectedFiles: 被拒绝的文件列表\r\n    message.error(error.message);\r\n  }}\r\n/>\r\n```\r\n\r\n### 自定义样式\r\n\r\n通过 `classNames` 可以覆盖各部分的样式, 基本包含了组件中出现所有html元素：\r\n\r\n```tsx\r\n<FileUploader\r\n  handlers={handlers}\r\n  classNames={{\r\n    container: 'my-uploader',           // 最外层容器\r\n    dragZone: {\r\n      container: 'my-drop-zone',        // 拖拽区容器\r\n      dragArea: 'my-drag-area',         // 拖拽区域\r\n      dragging: 'my-dragging',          // 拖拽中状态\r\n      disabled: 'my-disabled',          // 禁用状态\r\n      icon: 'my-icon',                  // 图标\r\n      description: 'my-description',    // 提示文字\r\n      input: 'my-input',                // 文件输入框\r\n    },\r\n    fileList: {\r\n      container: 'my-file-list',        // 文件列表容器\r\n      title: 'my-file-list-title',      // 文件列表标题\r\n      listWrapper: 'my-list-wrapper',   // 文件列表包装器\r\n      empty: 'my-empty-state',          // 空状态\r\n    },\r\n    fileItem: {\r\n      container: 'my-file-item',        // 单个文件项\r\n      info: 'my-file-info',             // 文件信息区域\r\n      icon: 'my-file-icon',             // 文件图标\r\n      name: 'my-file-name',             // 文件名\r\n      relativePath: 'my-relative-path', // 相对路径\r\n      status: 'my-status',              // 状态区域\r\n      statusText: 'my-status-text',     // 状态文字\r\n      progress: 'my-progress',          // 进度条\r\n      pauseBtn: 'my-pause-btn',         // 暂停按钮\r\n      resumeBtn: 'my-resume-btn',       // 继续按钮\r\n      closeBtn: 'my-close-btn',         // 关闭按钮\r\n    },\r\n  }}\r\n/>\r\n```\r\n\r\n### 使用场景\r\n\r\n```tsx\r\n// 场景 1：基础上传\r\n<FileUploader handlers={handlers} />\r\n\r\n// 场景 2：只允许上传图片，最多 5 张\r\n<FileUploader\r\n  handlers={handlers}\r\n  accept=\"image/*\"\r\n  maxFiles={5}\r\n  directory={false}\r\n/>\r\n\r\n// 场景 3：大文件上传，限制 50GB\r\n<FileUploader\r\n  handlers={handlers}\r\n  maxSize={50 * 1024 * 1024 * 1024}\r\n  dragAreaDescription=\"支持上传最大 50GB 的文件\"\r\n/>\r\n\r\n// 场景 4：自定义校验（只允许特定命名格式）\r\n<FileUploader\r\n  handlers={handlers}\r\n  fileValidation={(file) => /^data_\\d+\\.csv$/.test(file.name)}\r\n  onDropZoneError={(e) => message.error('文件名必须是 data_数字.csv 格式')}\r\n/>\r\n```\r\n\r\n## Hooks 详解\r\n\r\n如果你需要自定义 UI 或更细粒度的控制，可以直接使用 Hooks。我们提供了 5 个 Hook，按需选用：\r\n\r\n### useUpload\r\n\r\n**主 Hook**，整合了下面 4 个 Hook 的所有功能。如果你不确定用哪个，直接用这个就对了。\r\n\r\n```tsx\r\nconst {\r\n  // 来自 useUploadFiles\r\n  files,\r\n  getFileById,\r\n  pendingFiles,\r\n  uploadingFiles,\r\n  successFiles,\r\n  failedFiles,\r\n  pausedFiles,\r\n\r\n  // 来自 useUploadOperations\r\n  addFiles,\r\n  removeFile,\r\n  clearSucceeded,\r\n  clearAll,\r\n\r\n  // 来自 useUploadControl\r\n  start,\r\n  pause,\r\n  resume,\r\n  cancel,\r\n\r\n  // 来自 useUploadBatch\r\n  startAll,\r\n  pauseAll,\r\n  resumeAll,\r\n  cancelAll,\r\n} = useUpload();\r\n```\r\n\r\n---\r\n\r\n### useUploadFiles\r\n\r\n只读文件状态，适合只需要展示文件列表、不需要操作的场景。\r\n\r\n```tsx\r\nconst {\r\n  files,           // UploadFile[] - 所有文件\r\n  getFileById,     // (id: string) => UploadFile | undefined\r\n  pendingFiles,    // UploadFile[] - 等待上传的文件\r\n  uploadingFiles,  // UploadFile[] - 正在上传的文件\r\n  successFiles,  // UploadFile[] - 上传完成的文件\r\n  failedFiles,     // UploadFile[] - 上传失败的文件\r\n  pausedFiles,     // UploadFile[] - 已暂停的文件\r\n} = useUploadFiles();\r\n```\r\n\r\n**UploadFile 结构：**\r\n\r\n```ts\r\ninterface UploadFile {\r\n  id: string;              // 文件唯一标识\r\n  file: File;              // 原始 File 对象\r\n  fileName: string;        // 文件名\r\n  fileSize: number;        // 文件大小（字节）\r\n  status: UploadStatusType; // 状态：pending | preparing | uploading | paused | merging | success | failed | cancelled\r\n  progress: number;        // 上传进度（0-100）\r\n  uploadId: string;        // 服务端返回的上传 ID\r\n  chunks: ChunkState[];    // 分片状态列表\r\n  error?: string;          // 错误信息\r\n  createdAt: number;       // 添加时间戳\r\n}\r\n```\r\n\r\n---\r\n\r\n### useUploadOperations\r\n\r\n文件队列管理，用于添加、删除、清理文件。\r\n\r\n```tsx\r\nconst {\r\n  addFiles,        // 添加文件到队列\r\n  removeFile,      // 移除单个文件\r\n  clearSucceeded,  // 清理所有已完成的文件\r\n  clearAll,        // 清理所有文件\r\n} = useUploadOperations();\r\n```\r\n\r\n**addFiles 用法：**\r\n\r\n```tsx\r\n// 方式 1：所有文件使用相同的 handlers\r\naddFiles(fileList, {\r\n  handlers: {\r\n    onGetUploadUrls: ...,\r\n    onPartComplete: ...,\r\n    onFileComplete: ...,\r\n  },\r\n});\r\n\r\n// 方式 2：每个文件使用不同的 handlers（比如上传到不同目录）\r\naddFiles(fileList, {\r\n  getHandlers: (file) => ({\r\n    onGetUploadUrls: (fileName, partCount) =>\r\n      api.getUploadUrls(getFolderIdFromFileName(file.name), fileName, partCount),\r\n    onPartComplete: ...,\r\n    onFileComplete: ...,\r\n  }),\r\n});\r\n```\r\n\r\n**其他方法：**\r\n\r\n```tsx\r\nremoveFile(fileId);   // 移除文件，会触发 handlers.onDeleteFile\r\nclearSucceeded();     // 清理所有 status === 'success' 的文件\r\nclearAll();           // 清理所有文件（不管状态）\r\n```\r\n\r\n---\r\n\r\n### useUploadControl\r\n\r\n单文件控制，用于控制单个文件的上传流程。\r\n\r\n```tsx\r\nconst {\r\n  start,   // (id: string) => Promise<void> - 开始上传\r\n  pause,   // (id: string) => void - 暂停上传\r\n  resume,  // (id: string) => Promise<void> - 恢复上传\r\n  cancel,  // (id: string) => void - 取消上传\r\n} = useUploadControl();\r\n```\r\n\r\n**示例：**\r\n\r\n```tsx\r\nfunction FileActions({ file }: { file: UploadFile }) {\r\n  const { start, pause, resume, cancel } = useUploadControl();\r\n\r\n  return (\r\n    <div>\r\n      {file.status === 'pending' && (\r\n        <button onClick={() => start(file.id)}>开始</button>\r\n      )}\r\n      {file.status === 'uploading' && (\r\n        <button onClick={() => pause(file.id)}>暂停</button>\r\n      )}\r\n      {file.status === 'paused' && (\r\n        <button onClick={() => resume(file.id)}>继续</button>\r\n      )}\r\n      {['pending', 'uploading', 'paused'].includes(file.status) && (\r\n        <button onClick={() => cancel(file.id)}>取消</button>\r\n      )}\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n---\r\n\r\n### useUploadBatch\r\n\r\n批量操作，一次控制所有文件。\r\n\r\n```tsx\r\nconst {\r\n  startAll,   // () => Promise<void> - 开始所有 pending 文件\r\n  pauseAll,   // () => void - 暂停所有 uploading 文件\r\n  resumeAll,  // () => Promise<void> - 恢复所有 paused 文件\r\n  cancelAll,  // () => void - 取消所有未完成的文件\r\n} = useUploadBatch();\r\n```\r\n\r\n**示例：**\r\n\r\n```tsx\r\nfunction BatchControls() {\r\n  const { pendingFiles, uploadingFiles, pausedFiles } = useUploadFiles();\r\n  const { startAll, pauseAll, resumeAll, cancelAll } = useUploadBatch();\r\n\r\n  return (\r\n    <div>\r\n      {pendingFiles.length > 0 && (\r\n        <button onClick={startAll}>全部开始 ({pendingFiles.length})</button>\r\n      )}\r\n      {uploadingFiles.length > 0 && (\r\n        <button onClick={pauseAll}>全部暂停 ({uploadingFiles.length})</button>\r\n      )}\r\n      {pausedFiles.length > 0 && (\r\n        <button onClick={resumeAll}>全部继续 ({pausedFiles.length})</button>\r\n      )}\r\n      <button onClick={cancelAll}>全部取消</button>\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n---\r\n\r\n### 如何选择 Hook？\r\n\r\n| 场景 | 推荐 Hook |\r\n| --- | --- |\r\n| 完整功能，不想分开引入 | `useUpload` |\r\n| 只需要展示文件列表 | `useUploadFiles` |\r\n| 只需要添加/删除文件 | `useUploadOperations` |\r\n| 只需要控制单个文件 | `useUploadControl` |\r\n| 只需要批量操作 | `useUploadBatch` |\r\n| 组合使用，按需引入 | 分别引入需要的 Hook |\r\n\r\n## 子组件详解\r\n\r\n如果你不想用 `Uploader` 一体化组件，可以自由组合这三个子组件来构建自定义 UI。\r\n\r\n### UploaderDropZone\r\n\r\n拖拽上传区域，支持点击选择、拖拽文件、文件夹上传。这是一个纯 UI 组件，不依赖上传状态。\r\n\r\n#### Props\r\n\r\n| 属性 | 类型 | 默认值 | 必填 | 说明 |\r\n| --- | --- | --- | --- | --- |\r\n| `onDrop` | `(files: File[]) => void` | - | ✅ | 文件选择/拖入后的回调 |\r\n| `accept` | `string` | `''` | | 允许的文件类型，如 `\"image/*\"` 或 `\".pdf,.doc\"` |\r\n| `maxSize` | `number` | - | | 单文件大小限制（字节） |\r\n| `maxFiles` | `number` | - | | 最大文件数量 |\r\n| `directory` | `boolean` | `false` | | 是否支持文件夹上传 |\r\n| `disabled` | `boolean` | `false` | | 禁用状态 |\r\n| `dragAreaDescription` | `ReactNode` | `'点击或拖拽上传文件'` | | 提示文案 |\r\n| `icon` | `ReactNode \\| string` | - | | 自定义图标（组件或图片路径） |\r\n| `fileValidation` | `(file: File) => boolean \\| Promise<boolean>` | - | | 自定义文件校验 |\r\n| `onError` | `(error: DropZoneError) => void` | - | | 校验失败回调 |\r\n| `classNames` | `UploaderDropZoneClassNames` | - | | 自定义样式 |\r\n\r\n#### classNames 结构\r\n\r\n```ts\r\ninterface UploaderDropZoneClassNames {\r\n  container?: string;    // 容器\r\n  dragArea?: string;     // 拖拽区域\r\n  dragging?: string;     // 拖拽中状态\r\n  disabled?: string;     // 禁用状态\r\n  icon?: string;         // 图标\r\n  description?: string;  // 提示文字\r\n  input?: string;        // 隐藏的 input\r\n}\r\n```\r\n\r\n#### 示例\r\n\r\n```tsx\r\nimport { UploaderDropZone } from '@/components/file-uploader';\r\n\r\nfunction MyDropZone() {\r\n  const handleDrop = (files: File[]) => {\r\n    console.log('选中的文件:', files);\r\n    // 通常这里调用 addFiles\r\n  };\r\n\r\n  return (\r\n    <UploaderDropZone\r\n      onDrop={handleDrop}\r\n      accept=\"image/*\"\r\n      maxSize={10 * 1024 * 1024}\r\n      dragAreaDescription=\"拖入图片或点击上传\"\r\n      onError={(error) => console.error(error.message)}\r\n    />\r\n  );\r\n}\r\n```\r\n\r\n---\r\n\r\n### UploaderFileListLayout\r\n\r\n文件列表容器，显示文件数量标题和空状态。内部使用 `useUploadFiles` 获取文件列表长度。\r\n\r\n#### Props\r\n\r\n| 属性 | 类型 | 默认值 | 必填 | 说明 |\r\n| --- | --- | --- | --- | --- |\r\n| `children` | `ReactNode` | - | ✅ | 子元素（通常是 `UploaderFileItem` 列表） |\r\n| `emptyText` | `string` | `'暂无文件'` | | 空状态提示文案 |\r\n| `classNames` | `FileListClassNames` | - | | 自定义样式 |\r\n\r\n#### classNames 结构\r\n\r\n```ts\r\ninterface FileListClassNames {\r\n  container?: string;  // 列表容器\r\n  empty?: string;      // 空状态容器\r\n}\r\n```\r\n\r\n#### 示例\r\n\r\n```tsx\r\nimport { UploaderFileListLayout, UploaderFileItem, useUploadFiles } from '@/components/file-uploader';\r\n\r\nfunction MyFileList() {\r\n  const { files } = useUploadFiles();\r\n\r\n  return (\r\n    <UploaderFileListLayout emptyText=\"还没有上传任何文件\">\r\n      {files.map((file) => (\r\n        <UploaderFileItem key={file.id} file={file} />\r\n      ))}\r\n    </UploaderFileListLayout>\r\n  );\r\n}\r\n```\r\n\r\n---\r\n\r\n### UploaderFileItem\r\n\r\n单个文件项，显示文件名、状态、进度圈、操作按钮。这是一个受控组件，需要传入 `file` 和操作回调。\r\n\r\n#### Props\r\n\r\n| 属性 | 类型 | 默认值 | 必填 | 说明 |\r\n| --- | --- | --- | --- | --- |\r\n| `file` | `UploadFile` | - | ✅ | 文件对象 |\r\n| `onCancel` | `(id: string) => void` | - | | 取消上传回调 |\r\n| `onRemove` | `(id: string) => void` | - | | 移除文件回调（用于已完成/失败/已取消的文件） |\r\n| `onPause` | `(id: string) => void` | - | | 暂停上传回调 |\r\n| `onResume` | `(id: string) => void` | - | | 恢复上传回调 |\r\n| `classNames` | `UploaderFileItemClassNames` | - | | 自定义样式 |\r\n\r\n#### classNames 结构\r\n\r\n```ts\r\ninterface UploaderFileItemClassNames {\r\n  container?: string;   // 根容器\r\n  info?: string;        // 文件信息区域\r\n  icon?: string;        // 文件图标\r\n  name?: string;        // 文件名\r\n  status?: string;      // 状态区域\r\n  statusText?: string;  // 状态文字\r\n  progress?: string;    // 进度圈容器\r\n  pauseBtn?: string;    // 暂停按钮\r\n  resumeBtn?: string;   // 继续按钮\r\n  closeBtn?: string;    // 关闭/取消按钮\r\n}\r\n```\r\n\r\n#### 状态显示逻辑\r\n\r\n- **关闭按钮**：始终显示。已完成/失败/已取消时调用 `onRemove`，其他状态调用 `onCancel`\r\n- **暂停按钮**：上传中且传入了 `onPause` 时显示\r\n- **继续按钮**：已暂停且传入了 `onResume` 时显示\r\n\r\n#### 示例\r\n\r\n```tsx\r\nimport { UploaderFileItem, useUploadFiles, useUploadControl } from '@/components/file-uploader';\r\n\r\nfunction MyFileItem({ file }: { file: UploadFile }) {\r\n  const { pause, resume, cancel } = useUploadControl();\r\n  const { removeFile } = useUploadOperations();\r\n\r\n  return (\r\n    <UploaderFileItem\r\n      file={file}\r\n      onPause={pause}\r\n      onResume={resume}\r\n      onCancel={cancel}\r\n      onRemove={removeFile}\r\n    />\r\n  );\r\n}\r\n```\r\n\r\n---\r\n\r\n### 组合使用完整示例\r\n\r\n```tsx\r\nimport {\r\n  UploadProvider,\r\n  UploaderDropZone,\r\n  UploaderFileListLayout,\r\n  UploaderFileItem,\r\n  useUpload,\r\n} from '@/components/file-uploader';\r\n\r\nfunction CustomUploader({ datasetId }: { datasetId: string }) {\r\n  const { files, addFiles, pause, resume, cancel, removeFile } = useUpload();\r\n\r\n  const handlers = {\r\n    onGetUploadUrls: (fileName, partCount) => api.getUploadUrls(datasetId, fileName, partCount),\r\n    onPartComplete: (fileName, uploadId, partNum) => api.onPartComplete(datasetId, uploadId, partNum),\r\n    onFileComplete: (fileName, uploadId) => api.onFileComplete(datasetId, uploadId),\r\n  };\r\n\r\n  return (\r\n    <div className=\"my-uploader\">\r\n      {/* 拖拽区 */}\r\n      <UploaderDropZone\r\n        onDrop={(droppedFiles) => addFiles(droppedFiles, { handlers })}\r\n        accept=\"image/*,.pdf\"\r\n        maxSize={100 * 1024 * 1024}\r\n        directory\r\n      />\r\n\r\n      {/* 文件列表 */}\r\n      <UploaderFileListLayout emptyText=\"拖入文件开始上传\">\r\n        {files.map((file) => (\r\n          <UploaderFileItem\r\n            key={file.id}\r\n            file={file}\r\n            onPause={pause}\r\n            onResume={resume}\r\n            onCancel={cancel}\r\n            onRemove={removeFile}\r\n          />\r\n        ))}\r\n      </UploaderFileListLayout>\r\n    </div>\r\n  );\r\n}\r\n\r\n// 使用\r\nfunction App() {\r\n  return (\r\n    <UploadProvider>\r\n      <CustomUploader datasetId=\"123\" />\r\n    </UploadProvider>\r\n  );\r\n}\r\n```\r\n"}}]);